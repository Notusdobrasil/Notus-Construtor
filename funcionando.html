<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Construtor de Organograma</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        #canvas {
            width: 100%;
            height: 100%;
            background-color: #f0f2f5;
            background-image:
                linear-gradient(rgba(0, 0, 0, 0.08) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 0, 0, 0.08) 1px, transparent 1px);
            background-size: 20px 20px;
            overflow: hidden;
            cursor: grab;
        }
        .view-mode #canvas {
            background-image: none;
            cursor: default;
        }
        #world {
            position: absolute;
            top: 0;
            left: 0;
            transform-origin: top left;
        }
        .card {
            position: absolute;
            background-color: white;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            border: 2px solid #6366f1;
            width: 180px;
            height: 90px;
            cursor: pointer;
            user-select: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 0.5rem;
            transition: box-shadow 0.2s, border-color 0.2s;
        }
        .card:hover {
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }
        .card.dragging {
            cursor: grabbing;
            z-index: 1000;
            box-shadow: 0 25px 50px -12px rgb(0 0 0 / 0.25);
        }
        .card.selected-for-connection {
            border-color: #f59e0b; /* amber-500 */
            border-width: 3px;
        }
        .card.card-department {
            background-color: #3b82f6;
            color: white;
            border-color: #2563eb;
        }
        .card.card-department .title {
             color: #bfdbfe;
        }
        .card.card-department .card-photo {
            display: none;
        }
        .card .add-btn {
            position: absolute;
            width: 24px;
            height: 24px;
            background-color: #6366f1;
            color: white;
            border-radius: 9999px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            border: 2px solid white;
            opacity: 0;
            transition: opacity 0.2s, transform 0.2s;
            z-index: 10;
        }
        .card:hover .add-btn {
            opacity: 1;
        }
        .view-mode .card .add-btn {
            display: none;
        }
        .add-btn:hover {
            transform: scale(1.1);
        }
        .add-btn-top { top: -14px; left: 50%; transform: translateX(-50%); }
        .add-btn-right { right: -14px; top: 50%; transform: translateY(-50%); }
        .add-btn-bottom { bottom: -14px; left: 50%; transform: translateX(-50%); }
        .add-btn-left { left: -14px; top: 50%; transform: translateY(-50%); }
        
        .card-photo {
            width: 32px;
            height: 32px;
            border-radius: 9999px;
            object-fit: cover;
            margin-bottom: 4px;
            background-color: #e2e8f0;
        }
        #svg-layer {
            position: absolute;
            top: 0;
            left: 0;
            overflow: visible;
            pointer-events: none;
            z-index: 0;
        }
        #card-layer {
            position: relative;
            z-index: 1;
        }
        #connectModeBtn.active {
            background-color: #a855f7;
            box-shadow: inset 0 2px 4px 0 rgb(0 0 0 / 0.2);
        }
    </style>
</head>
<body class="bg-gray-200 h-screen overflow-hidden flex flex-col">

    <!-- Cabeçalho com Controles -->
    <header id="header" class="flex-shrink-0 bg-white p-2 shadow-md z-10 flex justify-between items-center">
        <h1 class="text-lg font-bold text-gray-700">Construtor de Organograma</h1>
        <div id="edit-controls" class="flex items-center space-x-2">
            <button id="addFirstCardBtn" class="bg-indigo-500 text-white font-semibold py-2 px-4 rounded-lg shadow-md hover:bg-indigo-600 transition duration-300 flex items-center">
                <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path></svg>
                Adicionar
            </button>
            <button id="connectModeBtn" class="bg-purple-500 text-white font-semibold py-2 px-4 rounded-lg shadow-md hover:bg-purple-600 transition duration-300">Conectar</button>
            <button id="resetViewBtn" class="bg-gray-500 text-white font-semibold py-2 px-4 rounded-lg shadow-md hover:bg-gray-600 transition duration-300">Resetar</button>
            <button id="clearAllBtn" class="bg-red-500 text-white font-semibold py-2 px-4 rounded-lg shadow-md hover:bg-red-600 transition duration-300">Limpar</button>
            <button id="viewModeBtn" class="bg-teal-500 text-white font-semibold py-2 px-4 rounded-lg shadow-md hover:bg-teal-600 transition duration-300">Visualizar</button>
        </div>
    </header>

    <!-- Canvas -->
    <main class="flex-grow relative">
        <div id="canvas">
            <div id="world">
                <svg id="svg-layer"></svg>
                <div id="card-layer"></div>
            </div>
        </div>
    </main>

    <!-- Modal de Edição -->
    <div id="editModal" class="hidden fixed inset-0 bg-black bg-opacity-50 z-20 flex items-center justify-center">
        <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-md">
            <h2 class="text-xl font-bold mb-4">Editar Card</h2>
            <div class="space-y-4">
                 <div>
                    <label for="cardType" class="block text-sm font-medium text-gray-700">Tipo de Card</label>
                    <select id="cardType" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                        <option value="employee">Colaborador</option>
                        <option value="department">Setor / Função</option>
                    </select>
                </div>
                <div id="imageUrl-wrapper">
                    <label for="imageUrl" class="block text-sm font-medium text-gray-700">URL da Foto</label>
                    <input type="text" id="imageUrl" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                </div>
                <div>
                    <label for="cardName" class="block text-sm font-medium text-gray-700">Nome / Cargo</label>
                    <input type="text" id="cardName" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                </div>
                <div>
                    <label for="cardTitle" class="block text-sm font-medium text-gray-700">Descrição / Pessoa</label>
                    <input type="text" id="cardTitle" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                </div>
            </div>
            <div class="mt-6 flex justify-between items-center">
                <button id="deleteCardBtn" class="bg-red-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-red-700 transition">Excluir Card</button>
                <div class="space-x-3">
                    <button id="cancelModalBtn" class="bg-gray-500 text-white font-semibold py-2 px-4 rounded-lg hover:bg-gray-600 transition">Cancelar</button>
                    <button id="saveModalBtn" class="bg-indigo-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-indigo-700 transition">Salvar</button>
                </div>
            </div>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // DOM Elements
        const header = document.getElementById('header');
        const canvas = document.getElementById('canvas');
        const world = document.getElementById('world');
        const cardLayer = document.getElementById('card-layer');
        const svgLayer = document.getElementById('svg-layer');
        const addFirstCardBtn = document.getElementById('addFirstCardBtn');
        const connectModeBtn = document.getElementById('connectModeBtn');
        const resetViewBtn = document.getElementById('resetViewBtn');
        const clearAllBtn = document.getElementById('clearAllBtn');
        const viewModeBtn = document.getElementById('viewModeBtn');
        const editModal = document.getElementById('editModal');
        const saveModalBtn = document.getElementById('saveModalBtn');
        const cancelModalBtn = document.getElementById('cancelModalBtn');
        const deleteCardBtn = document.getElementById('deleteCardBtn');
        const cardTypeSelect = document.getElementById('cardType');
        const imageUrlWrapper = document.getElementById('imageUrl-wrapper');
        const imageUrlInput = document.getElementById('imageUrl');
        const cardNameInput = document.getElementById('cardName');
        const cardTitleInput = document.getElementById('cardTitle');

        let state = {
            cards: [],
            connections: [],
            pan: { x: 0, y: 0, scale: 1 },
            isViewMode: false,
            isConnectMode: false,
            firstConnectionCardId: null,
            editingCardId: null,
            dragging: {
                isDown: false,
                cardId: null,
                offset: { x: 0, y: 0 }
            }
        };

        const CARD_WIDTH = 180;
        const CARD_HEIGHT = 90;
        const SPACING_X = 80;
        const SPACING_Y = 80;

        // --- State Management ---
        function saveState() {
            localStorage.setItem('orgChartBuilderState', JSON.stringify(state));
        }

        function loadState() {
            const savedState = localStorage.getItem('orgChartBuilderState');
            if (savedState) {
                state = JSON.parse(savedState);
                // Reset transient state properties
                state.isViewMode = false;
                state.isConnectMode = false;
                state.firstConnectionCardId = null;
                state.dragging = { isDown: false, cardId: null, offset: {x: 0, y: 0} };
            }
            if (!state.pan) state.pan = { x: 0, y: 0, scale: 1 };
        }

        // --- Rendering ---
        function render() {
            cardLayer.innerHTML = '';
            svgLayer.innerHTML = '';
            
            document.body.classList.toggle('view-mode', state.isViewMode);

            if (state.isViewMode) {
                fitToScreen();
            } else {
                const transform = `translate(${state.pan.x}px, ${state.pan.y}px) scale(${state.pan.scale})`;
                world.style.transform = transform;
            }

            state.cards.forEach(renderCard);
            state.connections.forEach(renderConnection);
        }

        function renderCard(cardData) {
            const cardEl = document.createElement('div');
            cardEl.className = 'card';
            if (cardData.type === 'department') cardEl.classList.add('card-department');
            if (cardData.id === state.firstConnectionCardId) cardEl.classList.add('selected-for-connection');
            
            cardEl.style.left = `${cardData.x}px`;
            cardEl.style.top = `${cardData.y}px`;
            cardEl.dataset.id = cardData.id;

            const placeholderImg = `https://placehold.co/60x60/e2e8f0/64748b?text=${cardData.name.charAt(0)}`;
            cardEl.innerHTML = `
                <div class="add-btn add-btn-top" data-direction="top">+</div>
                <div class="add-btn add-btn-right" data-direction="right">+</div>
                <div class="add-btn add-btn-bottom" data-direction="bottom">+</div>
                <div class="add-btn add-btn-left" data-direction="left">+</div>
                <img class="card-photo" src="${cardData.imageUrl || placeholderImg}" onerror="this.src='${placeholderImg}'">
                <h3 class="name font-bold text-gray-800 text-sm">${cardData.name}</h3>
                <p class="title text-xs text-gray-500">${cardData.title}</p>
            `;
            cardLayer.appendChild(cardEl);
        }

        function renderConnection(conn) {
            const fromCard = state.cards.find(c => c.id === conn.from);
            const toCard = state.cards.find(c => c.id === conn.to);
            if (!fromCard || !toCard) return;

            const x1 = fromCard.x + CARD_WIDTH / 2;
            const y1 = fromCard.y + CARD_HEIGHT / 2;
            const x2 = toCard.x + CARD_WIDTH / 2;
            const y2 = toCard.y + CARD_HEIGHT / 2;

            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', x1);
            line.setAttribute('y1', y1);
            line.setAttribute('x2', x2);
            line.setAttribute('y2', y2);
            line.setAttribute('stroke', '#94a3b8');
            line.setAttribute('stroke-width', '2');
            svgLayer.appendChild(line);
        }

        // --- Card & Modal Logic ---
        function addCard(fromCardId = null, direction = null) {
            const newCard = {
                id: Date.now(),
                name: 'Novo Card',
                title: 'Descrição',
                imageUrl: '',
                type: 'employee',
                x: 0, y: 0
            };

            if (fromCardId && direction) {
                const fromCard = state.cards.find(c => c.id === fromCardId);
                if (fromCard) {
                    switch (direction) {
                        case 'top': newCard.x = fromCard.x; newCard.y = fromCard.y - CARD_HEIGHT - SPACING_Y; break;
                        case 'right': newCard.x = fromCard.x + CARD_WIDTH + SPACING_X; newCard.y = fromCard.y; break;
                        case 'bottom': newCard.x = fromCard.x; newCard.y = fromCard.y + CARD_HEIGHT + SPACING_Y; break;
                        case 'left': newCard.x = fromCard.x - CARD_WIDTH - SPACING_X; newCard.y = fromCard.y; break;
                    }
                    state.connections.push({ from: fromCard.id, to: newCard.id });
                }
            } else {
                const viewCenterX = (canvas.clientWidth / 2) - (CARD_WIDTH / 2);
                const viewCenterY = (canvas.clientHeight / 2) - (CARD_HEIGHT / 2);
                newCard.x = (viewCenterX - state.pan.x) / state.pan.scale;
                newCard.y = (viewCenterY - state.pan.y) / state.pan.scale;
            }
            state.cards.push(newCard);
            saveAndRender();
        }

        function deleteCard(cardId) {
            state.cards = state.cards.filter(c => c.id !== cardId);
            state.connections = state.connections.filter(conn => conn.from !== cardId && conn.to !== cardId);
            saveAndRender();
        }

        function openEditModal(cardId) {
            const card = state.cards.find(c => c.id === cardId);
            if (card) {
                state.editingCardId = cardId;
                cardTypeSelect.value = card.type || 'employee';
                imageUrlInput.value = card.imageUrl || '';
                cardNameInput.value = card.name;
                cardTitleInput.value = card.title;
                toggleImageType();
                editModal.classList.remove('hidden');
            }
        }
        
        function toggleImageType() {
            const isEmployee = cardTypeSelect.value === 'employee';
            imageUrlWrapper.style.display = isEmployee ? 'block' : 'none';
        }

        cardTypeSelect.addEventListener('change', toggleImageType);

        function closeEditModal() {
            state.editingCardId = null;
            editModal.classList.add('hidden');
        }

        saveModalBtn.addEventListener('click', () => {
            if (state.editingCardId) {
                const card = state.cards.find(c => c.id === state.editingCardId);
                if (card) {
                    card.type = cardTypeSelect.value;
                    card.imageUrl = imageUrlInput.value;
                    card.name = cardNameInput.value;
                    card.title = cardTitleInput.value;
                    saveAndRender();
                }
            }
            closeEditModal();
        });
        
        deleteCardBtn.addEventListener('click', () => {
            if (state.editingCardId && confirm('Tem certeza que deseja excluir este card?')) {
                deleteCard(state.editingCardId);
            }
            closeEditModal();
        });

        cancelModalBtn.addEventListener('click', closeEditModal);
        editModal.addEventListener('click', (e) => {
            if (e.target === editModal) closeEditModal();
        });

        // --- Event Handlers ---
        addFirstCardBtn.addEventListener('click', () => {
            if (state.cards.length === 0) addCard();
        });
        
        clearAllBtn.addEventListener('click', () => {
            if (confirm('Tem certeza que deseja apagar todo o organograma? Esta ação não pode ser desfeita.')) {
                state.cards = [];
                state.connections = [];
                saveAndRender();
            }
        });

        resetViewBtn.addEventListener('click', () => {
            state.pan = { x: 0, y: 0, scale: 1 };
            saveAndRender();
        });

        viewModeBtn.addEventListener('click', () => {
            saveState();
            window.open(window.location.href + '?view=true', '_blank');
        });

        connectModeBtn.addEventListener('click', () => {
            state.isConnectMode = !state.isConnectMode;
            state.firstConnectionCardId = null;
            connectModeBtn.classList.toggle('active', state.isConnectMode);
            render();
        });

        // --- Pan and Drag Logic ---
        let isPanning = false;
        let startPos = { x: 0, y: 0 };
        let startPan = { x: 0, y: 0 };

        canvas.addEventListener('mousedown', (e) => {
            if (state.isViewMode) return;
            
            const cardEl = e.target.closest('.card');
            if (cardEl && !state.isConnectMode) {
                // Start dragging card
                state.dragging.isDown = true;
                state.dragging.cardId = parseInt(cardEl.dataset.id);
                const card = state.cards.find(c => c.id === state.dragging.cardId);
                cardEl.classList.add('dragging');

                const mouseX = (e.clientX - state.pan.x) / state.pan.scale;
                const mouseY = (e.clientY - state.pan.y) / state.pan.scale;
                state.dragging.offset.x = mouseX - card.x;
                state.dragging.offset.y = mouseY - card.y;

            } else if (e.target === canvas) {
                // Start panning canvas
                isPanning = true;
                canvas.style.cursor = 'grabbing';
                startPos = { x: e.clientX, y: e.clientY };
                startPan = { ...state.pan };
            }
        });

        window.addEventListener('mousemove', (e) => {
            if (state.dragging.isDown) {
                // Drag card
                const card = state.cards.find(c => c.id === state.dragging.cardId);
                if (card) {
                    const mouseX = (e.clientX - state.pan.x) / state.pan.scale;
                    const mouseY = (e.clientY - state.pan.y) / state.pan.scale;
                    card.x = mouseX - state.dragging.offset.x;
                    card.y = mouseY - state.dragging.offset.y;
                    render();
                }
            } else if (isPanning && !state.isViewMode) {
                // Pan canvas
                const dx = e.clientX - startPos.x;
                const dy = e.clientY - startPos.y;
                state.pan.x = startPan.x + dx;
                state.pan.y = startPan.y + dy;
                render();
            }
        });

        window.addEventListener('mouseup', () => {
            if (state.dragging.isDown) {
                document.querySelector(`[data-id='${state.dragging.cardId}']`)?.classList.remove('dragging');
                state.dragging.isDown = false;
                state.dragging.cardId = null;
                saveState();
            }
            if (isPanning) {
                isPanning = false;
                canvas.style.cursor = 'grab';
                saveState();
            }
        });

        canvas.addEventListener('click', (e) => {
            if (state.isViewMode) return;
            const cardEl = e.target.closest('.card');

            if (state.isConnectMode && cardEl) {
                handleConnectionClick(parseInt(cardEl.dataset.id));
                return;
            }

            if (e.target.classList.contains('add-btn')) {
                const cardId = parseInt(cardEl.dataset.id);
                const direction = e.target.dataset.direction;
                addCard(cardId, direction);
            } else if (cardEl) {
                openEditModal(parseInt(cardEl.dataset.id));
            }
        });

        function handleConnectionClick(cardId) {
            if (!state.firstConnectionCardId) {
                state.firstConnectionCardId = cardId;
            } else {
                if (state.firstConnectionCardId !== cardId) {
                    const existingConnection = state.connections.find(c => 
                        (c.from === state.firstConnectionCardId && c.to === cardId) ||
                        (c.from === cardId && c.to === state.firstConnectionCardId)
                    );
                    if (!existingConnection) {
                        state.connections.push({ from: state.firstConnectionCardId, to: cardId });
                    }
                }
                state.firstConnectionCardId = null;
            }
            saveAndRender();
        }

        canvas.addEventListener('wheel', (e) => {
            if (state.isViewMode) return;
            e.preventDefault();
            const scaleAmount = 0.1;
            const oldScale = state.pan.scale;
            
            state.pan.scale *= (e.deltaY > 0 ? (1 - scaleAmount) : (1 + scaleAmount));
            state.pan.scale = Math.max(0.1, Math.min(state.pan.scale, 3));

            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            state.pan.x = mouseX - (mouseX - state.pan.x) * (state.pan.scale / oldScale);
            state.pan.y = mouseY - (mouseY - state.pan.y) * (state.pan.scale / oldScale);

            saveAndRender();
        });
        
        function fitToScreen() {
            if (state.cards.length === 0) return;

            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            state.cards.forEach(card => {
                minX = Math.min(minX, card.x);
                minY = Math.min(minY, card.y);
                maxX = Math.max(maxX, card.x + CARD_WIDTH);
                maxY = Math.max(maxY, card.y + CARD_HEIGHT);
            });

            const chartWidth = maxX - minX;
            const chartHeight = maxY - minY;
            const canvasWidth = canvas.clientWidth;
            const canvasHeight = canvas.clientHeight;

            const scaleX = canvasWidth / chartWidth;
            const scaleY = canvasHeight / chartHeight;
            const scale = Math.min(scaleX, scaleY) * 0.9; // 90% padding

            const newWidth = chartWidth * scale;
            const newHeight = chartHeight * scale;

            const offsetX = (canvasWidth - newWidth) / 2 - (minX * scale);
            const offsetY = (canvasHeight - newHeight) / 2 - (minY * scale);

            const transform = `translate(${offsetX}px, ${offsetY}px) scale(${scale})`;
            world.style.transform = transform;
        }

        // --- Initialization ---
        function initialize() {
            const urlParams = new URLSearchParams(window.location.search);
            const isViewOnly = urlParams.get('view') === 'true';
            
            loadState();

            if (isViewOnly) {
                state.isViewMode = true;
                header.style.display = 'none';
                document.body.style.overflow = 'hidden';
            }
            
            render();
        }
        
        function saveAndRender() {
            saveState();
            render();
        }

        initialize();
    });
    </script>
</body>
</html>
